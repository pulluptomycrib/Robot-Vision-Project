from vis_nav_game import Player, Action, Phase
import pygame
import cv2
import numpy as np
import os
import pickle
from sklearn.neighbors import BallTree

import logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(message)s')

class AutonomousPlayer(Player):
    def __init__(self):
        super(AutonomousPlayer, self).__init__()
        self.fpv = None
        self.screen = None
        self.goal = None
        self.tree = None
        self.path = []
        self.current_step = 0
        self.database = None
        self.save_dir = "data/images_subsample/"

        # Load precomputed VLAD descriptors if available
        if os.path.exists("VLAD_database.pkl"):
            self.database = pickle.load(open("VLAD_database.pkl", "rb"))
            self.tree = BallTree(self.database, leaf_size=50)

    def pre_navigation(self):
        super(AutonomousPlayer, self).pre_navigation()
        self.load_or_compute_vlad()

    def load_or_compute_vlad(self):
        """ Load or compute VLAD descriptors """
        if self.database is None:
            print("VLAD database not found. Exploration required.")
            self.database = []
            for img_name in sorted(os.listdir(self.save_dir)):
                img = cv2.imread(os.path.join(self.save_dir, img_name))
                vlad_feature = self.compute_vlad(img)
                self.database.append(vlad_feature)
            pickle.dump(self.database, open("VLAD_database.pkl", "wb"))
            self.tree = BallTree(self.database, leaf_size=50)

    def compute_vlad(self, img):
        """ Compute a dummy VLAD descriptor """
        return np.random.rand(128)  # Placeholder until dataset is available

    def act(self):
        """ Automatically decide movement """
        if not self.path:
            return Action.IDLE

        if self.current_step < len(self.path) - 1:
            next_index = self.path[self.current_step + 1]
            self.current_step += 1
            return self.determine_movement(self.path[self.current_step - 1], next_index)
        else:
            return Action.CHECKIN

    def determine_movement(self, current, next_node):
        """ Basic movement decision logic """
        return Action.FORWARD

    def see(self, fpv):
        """ Process first-person view and plan movement """
        self.fpv = fpv
        if self.goal is None:
            targets = self.get_target_images()
            if targets:
                self.goal = self.get_neighbor(targets[0])
                print(f'Goal ID: {self.goal}')
                self.find_path()

    def get_neighbor(self, img):
        """ Find the closest matching image """
        q_vlad = self.compute_vlad(img).reshape(1, -1)
        _, index = self.tree.query(q_vlad, 1)
        return index[0][0]

    def find_path(self):
        """ Plan a simple movement path """
        start_index = self.get_neighbor(self.fpv)
        self.path = [start_index, self.goal]
        self.current_step = 0

if __name__ == "__main__":
    import vis_nav_game
    vis_nav_game.play(the_player=AutonomousPlayer())
